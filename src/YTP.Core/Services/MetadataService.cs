using System;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using HtmlAgilityPack;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Formats.Jpeg;
using SixLabors.ImageSharp.Processing;
using TagLib;
using YTP.Core.Models;

namespace YTP.Core.Services
{
    public class MetadataService
    {
        private readonly HttpClient _http = new HttpClient();
    private readonly YoutubeExplode.YoutubeClient _youtube = new YoutubeExplode.YoutubeClient();
    private DeezerLyricsProvider? _deezer;
    private readonly YTP.Core.Settings.SettingsManager? _settingsManager;

    static readonly string[] ignoredComments = new[] { "Auto-generated by YouTube.", "Provided to YouTube by" };
    internal static readonly string[] IgnoredGeneres = new[] { "download", "out now", "mostercat", "video", "lyric", "release", "ncs", "records" };
    internal static readonly string[] ArtistsSeparators = new[] { "&", "feat.", "feat", "ft.", " ft ", "Feat.", " x ", " X " };
    internal static readonly string[] VideoTitleSeparators = new[] { " - ", " — " };

        public async Task<byte[]?> FetchAndPrepareAlbumArtAsync(string? url, CancellationToken ct = default)
        {
            if (string.IsNullOrEmpty(url)) return null;

            try
            {
                using var res = await _http.GetAsync(url, ct);
                if (!res.IsSuccessStatusCode) return null;
                using var stream = await res.Content.ReadAsStreamAsync(ct);
                using var image = await Image.LoadAsync(stream, ct);

                // Crop to square center and resize to 1000x1000
                var size = Math.Min(image.Width, image.Height);
                var cropX = (image.Width - size) / 2;
                var cropY = (image.Height - size) / 2;
                image.Mutate(x => x.Crop(new Rectangle(cropX, cropY, size, size)).Resize(new ResizeOptions { Size = new SixLabors.ImageSharp.Size(1000, 1000), Mode = ResizeMode.Max }));

                using var ms = new MemoryStream();
                await image.SaveAsync(ms, new JpegEncoder { Quality = 90 }, ct);
                return ms.ToArray();
            }
            catch
            {
                return null;
            }
        }

        private (string? album, int? track, int? year) ExtractAlbumTrackYearFromDescription(string title, string? description)
        {
            // Heuristics: look for patterns like "Album: NAME (Year)", "from the album NAME", "Track 3", "#3", "3/12" or title like "Song - Album (Year)"
            string? album = null;
            int? track = null;
            int? year = null;

            if (!string.IsNullOrWhiteSpace(description))
            {
                // Album: XYZ (2021)
                var m = Regex.Match(description, @"Album[:\s]+(?<album>.+?)(?:\(|$)", RegexOptions.IgnoreCase);
                if (m.Success)
                    album = m.Groups["album"].Value.Trim().TrimEnd('.', '\r', '\n');

                // Track #: 3 or Track 3
                var mt = Regex.Match(description, @"Track\s*[:#]?\s*(?<num>\d{1,3})", RegexOptions.IgnoreCase);
                if (mt.Success && int.TryParse(mt.Groups["num"].Value, out var tn))
                    track = tn;

                // look for pattern like "from the album NAME"
                var mf = Regex.Match(description, @"from the album\s+(?<album2>.+?)(?:[.\n]|$)", RegexOptions.IgnoreCase);
                if (mf.Success && string.IsNullOrWhiteSpace(album))
                    album = mf.Groups["album2"].Value.Trim();

                // year in parentheses or standalone 4-digit, plus other common phrases
                var my = Regex.Match(description, @"\((?<year>19\d{2}|20\d{2})\)");
                if (my.Success && int.TryParse(my.Groups["year"].Value, out var y))
                    year = y;
                if (!year.HasValue)
                {
                    var my2 = Regex.Match(description, @"(?<year>19\d{2}|20\d{2})");
                    if (my2.Success && int.TryParse(my2.Groups["year"].Value, out var y2))
                        year = y2;
                }

                // Additional common patterns: "released 2007", "released in 2007", "release: 2007", "©2007" or "© 2007"
                if (!year.HasValue)
                {
                    var mrelease = Regex.Match(description, @"released(?:\s|\:|\s+in\s+)?(?<year>19\d{2}|20\d{2})", RegexOptions.IgnoreCase);
                    if (mrelease.Success && int.TryParse(mrelease.Groups["year"].Value, out var ry)) year = ry;
                }
                if (!year.HasValue)
                {
                    var mcopy = Regex.Match(description, @"©\s*(?<year>19\d{2}|20\d{2})");
                    if (mcopy.Success && int.TryParse(mcopy.Groups["year"].Value, out var cy)) year = cy;
                }
                if (!year.HasValue)
                {
                    var mrel2 = Regex.Match(description, @"release(?:\s|\:)?(?:year)?\s*(?<year>19\d{2}|20\d{2})", RegexOptions.IgnoreCase);
                    if (mrel2.Success && int.TryParse(mrel2.Groups["year"].Value, out var ry2)) year = ry2;
                }
            }

            // Try title patterns like "Song - Album (2020)" or "Song (Album)"
            if (string.IsNullOrWhiteSpace(album) && !string.IsNullOrWhiteSpace(title))
            {
                var mt = Regex.Match(title, @"-(?<album>.+?)\((?<year>19\d{2}|20\d{2})\)");
                if (mt.Success)
                {
                    album = mt.Groups["album"].Value.Trim();
                    if (int.TryParse(mt.Groups["year"].Value, out var y)) year = y;
                }
                else
                {
                    var mt2 = Regex.Match(title, @"-(?<album>.+)$");
                    if (mt2.Success)
                        album = mt2.Groups["album"].Value.Trim();
                }
            }

            // If track still missing, try common title prefixes like "01 - Song" or "1. Song"
            if (!track.HasValue && !string.IsNullOrWhiteSpace(title))
            {
                var mnum = Regex.Match(title, @"^(\d{1,2})[.\-)]\s+", RegexOptions.IgnoreCase);
                if (mnum.Success && int.TryParse(mnum.Groups[1].Value, out var n))
                    track = n;
            }

            // Normalize album length
            if (!string.IsNullOrWhiteSpace(album))
            {
                album = album.Trim();
                if (album.Length > 200) album = album.Substring(0, 200).Trim();
            }

            return (album, track, year);
        }

        public MetadataService() { }

        public MetadataService(YTP.Core.Settings.SettingsManager settingsManager)
        {
            _settingsManager = settingsManager;
        }

        public async Task<string?> ScrapeLyricsAsync(string title, string artist, string? description = null, CancellationToken ct = default)
        {
                // Respect settings: if SkipLyricsScrape is true, skip any network scraping
                try
                {
                    if (_settingsManager != null && _settingsManager.Settings.SkipLyricsScrape)
                        return null;
                }
                catch { }

                // Try Deezer first (synced or plain)
                try
                {
                    _deezer ??= new DeezerLyricsProvider(_http);
                    var dz = await (_deezer?.FetchLyricsAsync(artist ?? string.Empty, title ?? string.Empty, ct))!.ConfigureAwait(false);
                    if (!string.IsNullOrWhiteSpace(dz)) return dz;
                }
                catch { }

                // Try Megalobiz next
                try
                {
                    var mb = await FetchLyricsFromMegalobizAsync(artist ?? string.Empty, title ?? string.Empty, ct).ConfigureAwait(false);
                    if (!string.IsNullOrWhiteSpace(mb)) return mb;
                }
                catch { }

            // If Megalobiz didn't yield, fall back to extracting lyrics embedded in the video's description only.
            if (!string.IsNullOrWhiteSpace(description))
            {
                var match = System.Text.RegularExpressions.Regex.Match(description, "(lyrics?:?[\\s\\r\\n]+.*?)(?:(?:\\n{2,}|\\r\\n{2,})(?:links|socials|subscribe|copyright|produced by|video by|mixed by|mastered by|music by|album by|uploaded by))?", System.Text.RegularExpressions.RegexOptions.Singleline | System.Text.RegularExpressions.RegexOptions.IgnoreCase);
                if (match.Success)
                {
                    var potential = match.Groups[1].Value;
                    var clean = System.Text.RegularExpressions.Regex.Replace(potential, "^lyrics:?\\s*", "", System.Text.RegularExpressions.RegexOptions.IgnoreCase).Trim();
                    if (clean.Length > 100 && clean.Split('\n').Length > 5)
                        return clean;
                }
            }

            return null;
        }

        // Port of the Python megalobiz scraper: search the site and scrape lyrics if found
        public async Task<string?> FetchLyricsFromMegalobizAsync(string artist, string songname, CancellationToken ct = default)
        {
            if (string.IsNullOrWhiteSpace(artist) && string.IsNullOrWhiteSpace(songname)) return null;

            try
            {
                var q = System.Web.HttpUtility.ParseQueryString(string.Empty);
                q["qry"] = string.Join(' ', new[] { artist, songname }.Where(s => !string.IsNullOrWhiteSpace(s)));
                q["display"] = "more";
                var url = $"https://www.megalobiz.com/search/all?{q}";

                using var res = await _http.GetAsync(url, ct).ConfigureAwait(false);
                if (!res.IsSuccessStatusCode) return null;
                var html = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false);

                var doc = new HtmlDocument();
                doc.LoadHtml(html);

                var container = doc.GetElementbyId("list_entity_container");
                if (container == null) return null;

                var links = container.SelectNodes(".//a[contains(@class,'entity_name')]");
                if (links == null || links.Count == 0) return null;

                var target = links.FirstOrDefault(l =>
                {
                    var text = (l.InnerText ?? string.Empty).ToLowerInvariant();
                    return (!string.IsNullOrWhiteSpace(artist) && text.Contains(artist.ToLowerInvariant())) && (!string.IsNullOrWhiteSpace(songname) && text.Contains(songname.ToLowerInvariant()));
                });

                if (target == null) return null;

                var href = target.GetAttributeValue("href", null);
                if (string.IsNullOrWhiteSpace(href)) return null;

                var pageUrl = href.StartsWith("http") ? href : "https://www.megalobiz.com" + href;

                using var res2 = await _http.GetAsync(pageUrl, ct).ConfigureAwait(false);
                if (!res2.IsSuccessStatusCode) return null;
                var pageHtml = await res2.Content.ReadAsStringAsync(ct).ConfigureAwait(false);

                var doc2 = new HtmlDocument();
                doc2.LoadHtml(pageHtml);

                var lyricsDiv = doc2.DocumentNode.SelectSingleNode("//div[contains(@class,'lyrics_details')]/span");
                if (lyricsDiv == null) return null;

                var lrc = HtmlEntity.DeEntitize(lyricsDiv.InnerText ?? string.Empty).Trim();
                if (string.IsNullOrWhiteSpace(lrc)) return null;

                return lrc;
            }
            catch
            {
                return null;
            }
        }

    // ...existing code... (original synchronous TagMp3 removed in favour of async TagMp3)
    public async Task TagMp3(string path, VideoItem item, byte[]? albumArt, string? lyrics, System.Collections.Generic.IEnumerable<(int timeInMs, string text)>? syncedLines = null)
        {
            try
            {
                // Try to fetch full video info to improve tagging (auto-generated descriptions etc)
                YoutubeExplode.Videos.Video? fullVideo = null;
                try
                {
                    fullVideo = await _youtube.Videos.GetAsync(item.Id).ConfigureAwait(false);
                }
                catch
                {
                    fullVideo = null;
                }

                // First, if video is auto-generated try the specialized parser
                if (fullVideo != null && !string.IsNullOrWhiteSpace(fullVideo.Description) && fullVideo.Description.Contains("Auto-generated by YouTube."))
                {
                        // Parse description lines similar to the original project, but be more robust
                        // - skip empty lines
                        // - skip "Provided to YouTube by" header
                        // - parse title and artists from lines that contain '·'
                        // - the next non-empty line after the title/artists is usually the album
                        // - extract year from '℗ YYYY', '© YYYY' or 'Released on: YYYY-MM-DD'
                        var description = (fullVideo.Description ?? string.Empty).Split('\n');
                        var titleFromDesc = string.Empty;
                        var artists = new System.Collections.Generic.List<string>();
                        var album = string.Empty;
                        DateTime? releaseDate = null;
                        var comment = new System.Text.StringBuilder();

                        for (int i = 0; i < description.Length; i++)
                        {
                            var raw = description[i] ?? string.Empty;
                            var line = raw.Trim();

                            if (string.IsNullOrWhiteSpace(line))
                                continue; // skip empty lines

                            // stop parsing when reaching the auto-generated footer
                            if (line.StartsWith("Auto-generated by YouTube.", StringComparison.OrdinalIgnoreCase))
                                break;

                            // skip the header line like "Provided to YouTube by ..."
                            if (line.StartsWith("Provided to YouTube by", StringComparison.OrdinalIgnoreCase))
                                continue;

                            // Parse released date line
                            if (line.StartsWith("Released on:", StringComparison.OrdinalIgnoreCase))
                            {
                                var parts = line.Split(new[] { ':' }, 2);
                                if (parts.Length > 1 && DateTime.TryParse(parts[1].Trim(), out var d))
                                    releaseDate = d.Date;
                                continue;
                            }

                            // Parse copyright / phonogram year like '℗ 2007' or '© 2007'
                            var mcopy = Regex.Match(line, @"℗\s*(?<year>19\d{2}|20\d{2})");
                            if (!mcopy.Success)
                                mcopy = Regex.Match(line, @"©\s*(?<year>19\d{2}|20\d{2})");
                            if (mcopy.Success && int.TryParse(mcopy.Groups["year"].Value, out var cy))
                                releaseDate ??= new DateTime(cy, 1, 1);

                            // Look for title and performers line
                            if (line.Contains('·'))
                            {
                                var titleAndArtists = line.Split('·').Select(x => x.Trim()).ToArray();
                                titleFromDesc = titleAndArtists.FirstOrDefault() ?? string.Empty;
                                if (titleAndArtists.Length > 1)
                                    artists.AddRange(titleAndArtists.Skip(1));

                                // Find next non-empty candidate for album (look ahead)
                                for (int j = i + 1; j < description.Length; j++)
                                {
                                    var cand = (description[j] ?? string.Empty).Trim();
                                    if (string.IsNullOrWhiteSpace(cand))
                                        continue;
                                    // if cand is a copyright or release line, skip it
                                    if (cand.StartsWith("℗") || cand.StartsWith("©") || cand.StartsWith("Released on:", StringComparison.OrdinalIgnoreCase) || ignoredComments.Any(x => cand.StartsWith(x, StringComparison.OrdinalIgnoreCase)))
                                        continue;

                                    album = cand;
                                    break;
                                }

                                // continue scanning to possibly extract year or other info
                                continue;
                            }

                            // Collect other lines as comment when nothing matched
                            if (!string.IsNullOrWhiteSpace(line))
                                comment.AppendLine(line);
                        }

                    // Apply tags
                    using var tfile = TagLib.File.Create(path);

                    // Title
                    tfile.Tag.Title = !string.IsNullOrWhiteSpace(titleFromDesc) ? titleFromDesc : (item.Title ?? string.Empty);

                    // Performers
                    if (artists.Count > 0)
                    {
                        for (int i = 0; i < artists.Count; i++)
                            artists[i] = YTP.Core.Utilities.NameCleaner.CleanName(artists[i]);

                        tfile.Tag.Performers = artists.ToArray();
                    }
                    else
                    {
                        var rawArtist = string.IsNullOrWhiteSpace(item.Channel) ? "Unknown Artist" : item.Channel;
                        rawArtist = YTP.Core.Utilities.NameCleaner.CleanName(rawArtist);
                        tfile.Tag.Performers = new[] { rawArtist };
                    }

                    // Album
                    if (!string.IsNullOrWhiteSpace(album))
                        tfile.Tag.Album = YTP.Core.Utilities.NameCleaner.CleanName(album);
                    else if (!string.IsNullOrWhiteSpace(item.Album))
                        tfile.Tag.Album = YTP.Core.Utilities.NameCleaner.CleanName(item.Album!);
                    else if (item.IsPlaylistItem && !string.IsNullOrWhiteSpace(item.PlaylistTitle))
                        tfile.Tag.Album = YTP.Core.Utilities.NameCleaner.CleanName(item.PlaylistTitle!);
                    else
                    {
                        var candidate = YTP.Core.Utilities.NameCleaner.CleanName(item.Channel ?? string.Empty);
                        var rawArtist = string.IsNullOrWhiteSpace(item.Channel) ? "Unknown Artist" : item.Channel;
                        rawArtist = YTP.Core.Utilities.NameCleaner.CleanName(rawArtist);
                        tfile.Tag.Album = !string.IsNullOrWhiteSpace(candidate) && !string.Equals(candidate, rawArtist, StringComparison.OrdinalIgnoreCase)
                            ? candidate
                            : $"{rawArtist} - Single";
                    }

                    // Track
                    if (item.PlaylistIndex.HasValue)
                    {
                        tfile.Tag.Track = (uint)item.PlaylistIndex.Value;
                        if (item.PlaylistTotal.HasValue)
                            tfile.Tag.TrackCount = (uint)item.PlaylistTotal.Value;
                    }

                    // Year - only if parsed releaseDate exists or explicit item.Year
                    if (item.Year.HasValue)
                        tfile.Tag.Year = (uint)item.Year.Value;
                    else if (releaseDate.HasValue)
                        tfile.Tag.Year = (uint)releaseDate.Value.Year;

                    // Comment
                    if (comment.Length > 0)
                        tfile.Tag.Comment = comment.ToString();

                    // Album art: prefer provided albumArt, otherwise try youtube thumbnail
                    if (albumArt != null)
                    {
                        var pic = new Picture { Data = albumArt, Type = PictureType.FrontCover, MimeType = "image/jpeg" };
                        tfile.Tag.Pictures = new IPicture[] { pic };
                    }
                    else
                    {
                        try
                        {
                            var tryUrl = $"https://img.youtube.com/vi/{item.Id}/maxresdefault.jpg";
                            var artBytes = await FetchAndPrepareAlbumArtAsync(tryUrl).ConfigureAwait(false);
                            if (artBytes != null)
                            {
                                var pic = new Picture { Data = artBytes, Type = PictureType.FrontCover, MimeType = "image/jpeg" };
                                tfile.Tag.Pictures = new IPicture[] { pic };
                            }
                        }
                        catch { }
                    }

                    // Lyrics (plain)
                    if (!string.IsNullOrEmpty(lyrics)) tfile.Tag.Lyrics = lyrics;

                    // If we have synced lines, write an LRC sidecar next to the mp3
                    try
                    {
                        if (syncedLines != null)
                        {
                            var lrcPath = Path.ChangeExtension(path, ".lrc");
                            using var sw = new StreamWriter(lrcPath, false, System.Text.Encoding.UTF8);
                            // Basic LRC header
                            sw.WriteLine($"[ti:{tfile.Tag.Title}]");
                            if (tfile.Tag.Performers?.Length > 0) sw.WriteLine($"[ar:{string.Join(" / ", tfile.Tag.Performers)}]");
                            if (!string.IsNullOrWhiteSpace(tfile.Tag.Album)) sw.WriteLine($"[al:{tfile.Tag.Album}]");
                            sw.WriteLine($"[by:ytp]");

                            foreach (var l in syncedLines)
                            {
                                var ms = l.timeInMs;
                                var minutes = ms / 60000;
                                var seconds = (ms % 60000) / 1000;
                                var centis = (ms % 1000) / 10; // hundredths
                                sw.WriteLine($"[{minutes:D2}:{seconds:D2}.{centis:D2}]{l.text}");
                            }
                        }
                    }
                    catch { }

                    tfile.Save();
                    return;
                }

                // Fallback: tag based on title heuristics
                // Similar to original project's TagFileBasedOnTitle
                var titleClean = (item.Title ?? string.Empty).Replace('—', '-').Trim();
                var genre = titleClean.Split('[', ']').ElementAtOrDefault(1) ?? string.Empty;
                if (!string.IsNullOrWhiteSpace(genre) && genre.Length < titleClean.Length)
                {
                    titleClean = titleClean.Replace($"[{genre}]", string.Empty);
                    var stringToRemove = titleClean.Split('[', ']', '【', '】').ElementAtOrDefault(1);
                    if (!string.IsNullOrWhiteSpace(stringToRemove))
                        titleClean = titleClean.Replace($"[{stringToRemove}]", string.Empty);
                }
                titleClean = titleClean.TrimStart(' ', '-', '[', ']').TrimEnd();

                using (var tfile = TagLib.File.Create(path))
                {
                    // Album / Track / AlbumArtists
                    if (!string.IsNullOrWhiteSpace(item.PlaylistTitle))
                        tfile.Tag.Album = item.PlaylistTitle;
                    if (item.PlaylistIndex.HasValue)
                        tfile.Tag.Track = (uint)item.PlaylistIndex.Value;
                    if (item.PlaylistTotal.HasValue)
                        tfile.Tag.TrackCount = (uint)item.PlaylistTotal.Value;

                    if (IgnoredGeneres.Any(g => genre.ToLower().Contains(g)))
                    {
                        // skip
                    }
                    else if (!string.IsNullOrWhiteSpace(genre))
                    {
                        tfile.Tag.Genres = genre.Split('/', '\\');
                    }

                    if (TryGetSongTitleAndPerformersFromTitle(titleClean, out var songTitle, out var songPerformers))
                    {
                        tfile.Tag.Title = songTitle;
                        tfile.Tag.Performers = songPerformers;
                    }
                    else
                    {
                        tfile.Tag.Title = item.Title;
                        var rawArtist = string.IsNullOrWhiteSpace(item.Channel) ? "Unknown Artist" : item.Channel;
                        rawArtist = YTP.Core.Utilities.NameCleaner.CleanName(rawArtist);
                        tfile.Tag.Performers = new[] { rawArtist };
                    }

                    // Album art
                    if (albumArt != null)
                    {
                        var pic = new Picture { Data = albumArt, Type = PictureType.FrontCover, MimeType = "image/jpeg" };
                        tfile.Tag.Pictures = new IPicture[] { pic };
                    }
                    else
                    {
                        try
                        {
                            var tryUrl = $"https://img.youtube.com/vi/{item.Id}/maxresdefault.jpg";
                            var artBytes = await FetchAndPrepareAlbumArtAsync(tryUrl).ConfigureAwait(false);
                            if (artBytes != null)
                            {
                                var pic = new Picture { Data = artBytes, Type = PictureType.FrontCover, MimeType = "image/jpeg" };
                                tfile.Tag.Pictures = new IPicture[] { pic };
                            }
                        }
                        catch { }
                    }

                    if (!string.IsNullOrEmpty(lyrics)) tfile.Tag.Lyrics = lyrics;

                    tfile.Save();
                }
            }
            catch
            {
                // swallow tagging errors for now; callers should log
            }
        }

        // Fetch synced lyrics using the youtube-music browse proxy used by the plugin.
        // This mirrors the YTMusic provider: call the /next?prettyPrint=false endpoint to get tabs,
        // find the lyrics tab, then call the proxied /browse endpoint with the browseId.
        public async Task<System.Collections.Generic.IEnumerable<(int timeInMs, string text)>?> FetchSyncedLyricsAsync(string videoId, CancellationToken ct = default)
        {
            try
            {
                // Try Deezer synced lyrics via provider based on video metadata if possible
                try
                {
                    _deezer ??= new DeezerLyricsProvider(_http);
                    // attempt to infer artist/title from video metadata
                    var meta = await _youtube.Videos.GetAsync(videoId).ConfigureAwait(false);
                    var possibleArtist = string.IsNullOrWhiteSpace(meta.Author?.ChannelTitle) ? string.Empty : meta.Author.ChannelTitle;
                    var possibleTitle = string.IsNullOrWhiteSpace(meta.Title) ? string.Empty : meta.Title;
                    var deezerLines = await _deezer.FetchSyncedLyricsAsync(possibleArtist, possibleTitle, ct).ConfigureAwait(false);
                    if (deezerLines != null && deezerLines.Any()) return deezerLines;
                }
                catch { }

                // Fallback to YouTube Music browse extraction (existing logic)
                var nextUrl = "https://music.youtube.com/youtubei/v1/next?prettyPrint=false";
                var nextPayload = new { videoId };
                var nextReq = new StringContent(System.Text.Json.JsonSerializer.Serialize(nextPayload), System.Text.Encoding.UTF8, "application/json");
                var res = await _http.PostAsync(nextUrl, nextReq, ct).ConfigureAwait(false);
                if (!res.IsSuccessStatusCode) return null;
                var nextJson = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false);

                using var doc = System.Text.Json.JsonDocument.Parse(nextJson);
                // Look for the lyrics tab's browseId in the JSON (multiple paths are possible)
                var browseId = FindBrowseIdForLyrics(doc.RootElement);
                if (string.IsNullOrEmpty(browseId)) return null;

                // Call the proxied browse endpoint (the plugin used a proxy; we call the public youtubei browse endpoint)
                var browseUrl = "https://www.youtube.com/youtubei/v1/browse?prettyPrint=false";
                var browsePayload = new { browseId, context = new { client = new { clientName = "26", clientVersion = "7.01.05" } } };
                var browseReq = new StringContent(System.Text.Json.JsonSerializer.Serialize(browsePayload), System.Text.Encoding.UTF8, "application/json");
                var res2 = await _http.PostAsync(browseUrl, browseReq, ct).ConfigureAwait(false);
                if (!res2.IsSuccessStatusCode) return null;
                var browseJson = await res2.Content.ReadAsStringAsync(ct).ConfigureAwait(false);
                using var doc2 = System.Text.Json.JsonDocument.Parse(browseJson);

                // Extract timed lyrics data from possible paths
                var lines = ExtractTimedLyricsFromBrowse(doc2.RootElement);
                return lines;
            }
            catch
            {
                return null;
            }
        }

        private static string? FindBrowseIdForLyrics(System.Text.Json.JsonElement root)
        {
            try
            {
                if (root.TryGetProperty("contents", out var contents))
                {
                    if (contents.TryGetProperty("singleColumnMusicWatchNextResultsRenderer", out var sc))
                    {
                        if (sc.TryGetProperty("tabbedRenderer", out var tr) && tr.TryGetProperty("watchNextTabbedResultsRenderer", out var wtr) && wtr.TryGetProperty("tabs", out var tabs) && tabs.ValueKind == System.Text.Json.JsonValueKind.Array)
                        {
                            foreach (var t in tabs.EnumerateArray())
                            {
                                var browseId = t.GetProperty("tabRenderer").GetProperty("endpoint").GetProperty("browseEndpoint").GetProperty("browseId").GetString();
                                // Heuristic: the lyrics tab contains MUSIC_PAGE_TYPE_TRACK_LYRICS in the nested config; try to detect that safely
                                try
                                {
                                    var pageType = t.GetProperty("tabRenderer").GetProperty("endpoint").GetProperty("browseEndpoint").GetProperty("browseEndpointContextSupportedConfigs").GetProperty("browseEndpointContextMusicConfig").GetProperty("pageType").GetString();
                                    if (pageType == "MUSIC_PAGE_TYPE_TRACK_LYRICS") return browseId;
                                }
                                catch { }
                            }
                        }
                    }
                }
            }
            catch { }
            return null;
        }

        private static System.Collections.Generic.IEnumerable<(int timeInMs, string text)>? ExtractTimedLyricsFromBrowse(System.Text.Json.JsonElement root)
        {
            try
            {
                // This attempts to follow the structure used by the plugin: elementRenderer -> newElement -> type -> componentType -> model -> timedLyricsModel -> lyricsData -> timedLyricsData
                if (root.TryGetProperty("contents", out var contents))
                {
                    if (contents.TryGetProperty("elementRenderer", out var elem))
                    {
                        var newElement = elem.GetProperty("newElement");
                        var model = newElement.GetProperty("type").GetProperty("componentType").GetProperty("model");
                        if (model.TryGetProperty("timedLyricsModel", out var timed))
                        {
                            if (timed.TryGetProperty("lyricsData", out var ld) && ld.TryGetProperty("timedLyricsData", out var tld) && tld.ValueKind == System.Text.Json.JsonValueKind.Array)
                            {
                                var list = new System.Collections.Generic.List<(int, string)>();
                                foreach (var it in tld.EnumerateArray())
                                {
                                    try
                                    {
                                        var cue = it.GetProperty("cueRange");
                                        var startStr = cue.GetProperty("startTimeMilliseconds").GetString();
                                        var text = it.GetProperty("lyricLine").GetString() ?? string.Empty;
                                        if (int.TryParse(startStr, out var ms))
                                            list.Add((ms, text.Trim() == "♪" ? string.Empty : text.Trim()));
                                    }
                                    catch { }
                                }
                                return list;
                            }
                        }
                    }
                }
            }
            catch { }
            return null;
        }

        public static bool TryGetSongTitleAndPerformersFromTitle(string title, out string songTitle, out string[] songPerformers)
        {
            songTitle = string.Empty;
            songPerformers = Array.Empty<string>();

            var index = title.LastIndexOf('-');

            if (index > 0)
            {
                songTitle = title[(index + 1)..].Trim(' ', '-');

                if (string.IsNullOrWhiteSpace(songTitle))
                {
                    index = title.IndexOf('-');

                    if (index > 0)
                    {
                        songTitle = title[(index + 1)..].Trim(' ', '-');
                    }
                }

                var separators = new string[] { "&", "feat.", "feat", "ft.", " ft ", "Feat.", " x ", " X " };
                songPerformers = title[..(index - 1)].Trim().Split(separators, StringSplitOptions.RemoveEmptyEntries);

                // Clean performers
                for (int i = 0; i < songPerformers.Length; i++)
                    songPerformers[i] = YTP.Core.Utilities.NameCleaner.CleanName(songPerformers[i]);

                return true;
            }

            return false;
        }

            private static string CleanNameSuffix(string name)
            {
                if (string.IsNullOrWhiteSpace(name)) return name ?? string.Empty;
                var s = name.Trim();
                // Common suffixes to remove
                var patterns = new[]
                {
                    " - Topic",
                    " - Official Audio",
                    " - Official Video",
                    "(Official Music Video)",
                    "(Official Audio)",
                    "[Official Music Video]",
                    "[Official Audio]"
                };
                foreach (var p in patterns)
                {
                    if (s.EndsWith(p, StringComparison.OrdinalIgnoreCase))
                    {
                        s = s.Substring(0, s.Length - p.Length).Trim();
                    }
                }

                // Remove common leading 'Album - ' prefixes
                if (s.StartsWith("Album - ", StringComparison.OrdinalIgnoreCase))
                    s = s.Substring(8).Trim();

                // Collapse multiple spaces
                s = System.Text.RegularExpressions.Regex.Replace(s, "\\s+", " ").Trim();
                return s;
            }
    }
}
